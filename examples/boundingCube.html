<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ConeFrustum - Optimised bounding cube</title>

    <style>
        body {
            color: #000;
            font-family: Monospace, sans-serif;
            font-size:13px;
            text-align:center;
            font-weight: bold;

            background-color: #fff;
            margin: 0;
            overflow: hidden;
        }

        #info {
            color:#000;
            position: absolute;
            top: 0; width: 100%;
            padding: 5px;

        }

        a {
            color: red;
        }
    </style>
</head>

<body>

<script src="../node_modules/three-full/builds/Three.iife.js"></script>
<script>
    var THREE = THREE || Three
</script>

<script src="../dist/browser/three-js-cone-frustum.js"></script>

<script src="../node_modules/dat.gui/build/dat.gui.min.js"></script>

<script>
    let renderer = new THREE.WebGLRenderer()
    document.body.appendChild(renderer.domElement)
    renderer.setClearColor( '#ffffff' )
    renderer.setClearAlpha( 1 )

    let scene = new THREE.Scene();

    let camera = new THREE.PerspectiveCamera( 75 );
    camera.position.setZ(40)

    let controls = new THREE.OrbitControls( camera, renderer.domElement )
    controls.addEventListener( 'change', render );
    controls.enableDamping = true; // An animation loop is required when either damping or auto-rotation are enabled
    controls.dampingFactor = 0.1;
    controls.minDistance = 10;
    controls.maxDistance = 1000;
    controls.keys = { UP: 0, DOWN: 0, LEFT: 0, RIGHT: 0 };

    let params = {
        C0_X: 0,
        C0_Y: 0,
        C0_Z: 0,
        R0: 4,
        C1_X: 10,
        C1_Y: 10,
        C1_Z: 10,
        R1: 1,
    }

    let geom = new THREE.BufferGeometry();

    let mesh = new THREE.Mesh(computeGeometry(), new THREE.MeshStandardMaterial({ color: 0xffaa00 }))
    mesh.material.side = THREE.DoubleSide
    scene.add(mesh);

    let light = new THREE.HemisphereLight( 0xffffff, 0xaaaaaa, 2.0 );
    scene.add( light );

    scene.add(new THREE.AxesHelper(20));

    scene.add( new THREE.GridHelper(40) );

    updateScreen()
    window.onresize = updateScreen;


    function updateScreen()
    {
        renderer.setSize( window.innerWidth, window.innerHeight )
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()

        render()
    }


    function computeGeometry() {
        let geom = new THREE.BufferGeometry();
        let positions = THREE.ConeFrustum.computeOptimisedDownscalingBoundingCube(
            new THREE.Vector3( params.C0_X, params.C0_Y, params.C0_Z ), params.R0,
            new THREE.Vector3( params.C1_X, params.C1_Y, params.C1_Z ), params.R1,
            new THREE.Vector3(), 0
        );
        geom.addAttribute('position', new THREE.BufferAttribute(positions, 3))
        geom.computeVertexNormals();
        return geom;
    }


    function render() {
        renderer.render(scene, camera)
    }


    let gui = new dat.GUI();

    gui.add(params, "C0_X", -20, 20, 0.5).onChange(updateGeom)
    gui.add(params, "C0_Y", -20, 20, 0.5).onChange(updateGeom)
    gui.add(params, "C0_Z", -20, 20, 0.5).onChange(updateGeom)
    gui.add(params, "R0", 0, 10, 0.2).onChange(updateGeom)
    gui.add(params, "C1_X", -20, 20, 0.5).onChange(updateGeom)
    gui.add(params, "C1_Y", -20, 20, 0.5).onChange(updateGeom)
    gui.add(params, "C1_Z", -20, 20, 0.5).onChange(updateGeom)
    gui.add(params, "R1", 0, 10, 0.2).onChange(updateGeom)

    function updateGeom() {
        mesh.geometry = computeGeometry();
        mesh.needsUpdate = true;
        render();
    }
</script>

</body>
</html>
