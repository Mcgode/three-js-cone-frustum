!(function(t, e) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = e(require("three-full")))
: "function" == typeof define && define.amd
? define(["three-full"], e)
: (t.THREEConeFrustum = e(t.THREE));
})(this, function(t) {
"use strict";
const e = (t = t && t.hasOwnProperty("default") ? t.default : t).Box3,
i = t.Vector3;
var s = new i();
class r {
constructor(t, e, s, r, a) {
(this.base = t || new i()),
(this.axis = e || new i(0, 1, 0)),
this.axis.normalize(),
(this.height = s || 1),
(this.radius0 = r || 0),
(this.radius1 = a || 0);
}
static fromCapsule(t, e, s, a) {
let h = new i();
return h.subVectors(s, t), new r(t, h.clone().normalize(), h.length(), e, a);
}
orthogonalProject(t, e) {
var i = s;
i.subVectors(t, this.base);
var r = i.lengthSq(),
a = i.dot(this.axis),
h = r - a * a,
o = a - ((h > 0 ? Math.sqrt(h) : 0) * (this.r0 - this.r1)) / this.h;
e
.copy(this.axis)
.multiplyScalar(o)
.add(this.base);
}
copy(t) {
(this.base = t.base.clone()),
(this.axis = t.axis.clone()),
(this.height = t.height),
(this.radius0 = t.radius0),
(this.radius1 = t.radius1);
}
clone() {
return new r().copy(this);
}
empty() {
return 0 === this.height || (0 === this.radius0 && 0 === this.radius1);
}
getBoundingBox(t) {
let s = this.base.clone(),
r = new i();
r.set(
Math.sqrt(1 * this.axis.x * this.axis.x),
Math.sqrt(1 * this.axis.y * this.axis.y),
Math.sqrt(1 * this.axis.z * this.axis.z)
),
r.multiplyScalar(this.radius0);
let a = new e(new i().subVectors(s, r), new i().addVectors(s, r));
r.divideScalar(this.radius0),
r.multiplyScalar(this.radius1),
s.addScaledVector(this.axis, this.height);
let h = new e(new i().subVectors(s, r), new i().addVectors(s, r));
return a.union(h), null != t && t.copy(a), a;
}
equals(t) {
return (
this.base.equals(t.base) &&
this.axis.equals(t.axis) &&
this.height === t.height &&
this.radius0 === t.radius0 &&
this.radius1 === t.radius1
);
}
}
(t.ConeFrustum = r),
(t.Ray.prototype.intersectsConeFrustum = (function() {
let t = new i(),
e = new i(),
s = new i();
return function(i, r) {
null == r && (r = e);
let a = i.radius1 - i.radius0,
h = 1 + Math.pow(a / i.height, 2),
o = (i.radius0 * a) / i.height;
t.subVectors(this.origin, i.base);
let d = t.dot(i.axis),
n = t.dot(t),
u = this.direction.dot(i.axis),
c = this.direction.dot(t),
l = this.direction.dot(this.direction),
x = i.radius0 * i.radius0 + 2 * o * d + h * d * d - n,
p = o * u + h * d * u - c,
f = h * u * u - l;
if (0 !== f) {
let a = p * p - f * x;
if (a < 0) return null;
if (0 !== a) {
let h = 0,
o = Math.sqrt(a),
d = (-p - o) / f;
s.copy(t), s.addScaledVector(this.direction, d);
let n = i.axis.dot(s);
d >= 0 && n >= 0 && n <= i.height && (e.addVectors(i.base, s), h++);
let u = (-p + o) / f;
return (
s.copy(t),
s.addScaledVector(this.direction, u),
(n = i.axis.dot(s)),
u >= 0 &&
(0 === h || d > u) &&
n >= 0 &&
n <= i.height &&
(e.addVectors(i.base, s), h++),
h && r.copy(e),
h ? e : null
);
}
{
let a = -p / f;
s.copy(t), s.addScaledVector(this.direction, a);
let h = i.axis.dot(s);
if (a >= 0 && h >= 0 && h <= i.height)
return e.addVectors(i.base, s), r.copy(e), e;
}
} else if (0 !== p) {
let a = (-2 * x) / p;
s.copy(t), s.addScaledVector(this.direction, a);
let h = i.axis.dot(s);
if (a >= 0 && h >= 0 && h <= i.height)
return e.addVectors(i.base, s), r.copy(e), r;
}
return null;
};
})());
return {};
});
