!(function(t, e) {
"object" == typeof exports && "undefined" != typeof module
? e(exports)
: "function" == typeof define && define.amd
? define(["exports"], e)
: e((t.THREEConeFrustum = {}));
})(this, function(t) {
"use strict";
const e = require("three-full"),
s = e.Box3,
i = e.Vector3,
a = e.Matrix4,
o = e.BoxBufferGeometry,
n = new i(),
r = (new i(), new i()),
h = (new i(), new a()),
c = new o(2, 2, 2).toNonIndexed().attributes.position;
class u {
constructor(t, e, s, a, o) {
(this.base = t || new i()),
(this.axis = e || new i(0, 1, 0)),
this.axis.normalize(),
(this.height = s || 1),
(this.radius0 = a || 0),
(this.radius1 = o || 0);
}
static fromCapsule(t, e, s, a) {
if (e > a) return this.fromCapsule(s, a, t, e);
const o = new i().subVectors(s, t);
if (0 === o.length()) throw "Capsule height must not be zero";
const n = (a - e) / o.length(),
r = o.length() + n * (e - a),
h = new i().copy(t).addScaledVector(o.normalize(), -n * e),
c = Math.cos(Math.asin(n));
return new u(h, o, r, e * c, a * c);
}
orthogonalProject(t, e) {
const s = n;
s.subVectors(t, this.base);
const i = s.lengthSq(),
a = s.dot(this.axis),
o = i - a * a,
r =
a - ((o > 0 ? Math.sqrt(o) : 0) * (this.radius0 - this.radius1)) / this.height;
e
.copy(this.axis)
.multiplyScalar(r)
.add(this.base);
}
copy(t) {
(this.base = t.base.clone()),
(this.axis = t.axis.clone()),
(this.height = t.height),
(this.radius0 = t.radius0),
(this.radius1 = t.radius1);
}
clone() {
return new u().copy(this);
}
empty() {
return 0 === this.height || (0 === this.radius0 && 0 === this.radius1);
}
getBoundingBox(t) {
const e = this.base.clone(),
a = new i();
a.set(
Math.sqrt(1 - this.axis.x * this.axis.x),
Math.sqrt(1 - this.axis.y * this.axis.y),
Math.sqrt(1 - this.axis.z * this.axis.z)
),
a.multiplyScalar(this.radius0);
const o = new s(new i().subVectors(e, a), new i().addVectors(e, a));
a.divideScalar(this.radius0),
a.multiplyScalar(this.radius1),
e.addScaledVector(this.axis, this.height);
const n = new s(new i().subVectors(e, a), new i().addVectors(e, a));
return o.union(n), null != t && t.copy(o), o;
}
computeOptimisedBoundingCube(t) {
const e = c.clone(),
s = Math.max(this.radius0, this.radius1);
h.makeScale(s, this.height / 2, s), e.applyMatrix4(h), n.set(0, 1, 0);
const i = n.angleTo(this.axis);
return (
n.cross(this.axis).normalize(),
n.length() > 0 && (h.makeRotationAxis(n, i), e.applyMatrix4(h)),
n
.copy(this.base)
.addScaledVector(this.axis, this.height / 2)
.sub(t),
h.makeTranslation(n.x, n.y, n.z),
e.applyMatrix4(h),
e.array
);
}
static computeOptimisedDownscalingBoundingCube(t, s, a, o, c, u) {
if (s > o)
return this.computeOptimisedDownscalingBoundingCube(a, o, t, s, c, u);
const d = new Float32Array([
-1,
-1,
-1,
1,
-1,
-1,
-1,
-1,
1,
1,
-1,
1,
-1,
1,
-1,
1,
1,
-1,
-1,
1,
1,
1,
1,
1,
-1,
1,
-1,
1,
1,
-1,
-1,
1,
1,
1,
1,
1
]),
l = [
0,
1,
3,
0,
3,
2,
6,
4,
0,
6,
0,
2,
7,
6,
2,
7,
2,
3,
5,
7,
3,
5,
3,
1,
4,
5,
1,
4,
1,
0,
10,
8,
4,
10,
4,
6,
11,
10,
6,
11,
6,
7,
9,
11,
7,
9,
7,
5,
8,
9,
5,
8,
5,
4,
9,
8,
10,
9,
10,
11
],
p = function() {
const t = new Float32Array(3 * l.length);
for (let e = 0; e < l.length; e++) {
const s = 3 * l[e];
(t[3 * e] = d[s]), (t[3 * e + 1] = d[s + 1]), (t[3 * e + 2] = d[s + 2]);
}
return t;
},
x = new i().subVectors(a, t);
if (0 === x.length()) throw "Capsule height must not be zero";
const g = (o - s) / x.length();
if (Math.abs(g) >= (1 / u) * 0.9999) {
x.addVectors(t, a).multiplyScalar(0.5);
for (let t = 0; t < d.length; t += 3)
(d[t] = x.x), (d[t + 1] = x.y), (d[t + 2] = x.z);
return p();
}
if (Math.abs(g) > 1)
return this.computeOptimisedDownscalingBoundingCube(t, u * s, a, u * o, c, 1);
const y = Math.cos(Math.asin(g)),
f = x.length() + g * (s - u * u * o),
m = x.length() + g * (s - o);
r.copy(t).addScaledVector(x.normalize(), -g * s);
const b = o * y;
let w = b > 0 ? (s * y) / b : 1;
for (let t = 0; t < 12; t += 3) (d[t] *= w), (d[t + 2] *= w);
w = (Math.cos(Math.asin(u * g)) * o * u) / b;
for (let t = 24; t < 36; t += 3) (d[t] *= w), (d[t + 2] *= w);
const M = (2 * m) / f - 1;
for (let t = 12; t < 24; t += 3) d[t + 1] = M;
const V = new e.BufferAttribute(p(), 3);
h.makeScale(b, f / 2, b), V.applyMatrix4(h), n.set(0, 1, 0);
const S = n.angleTo(x),
z = n.dot(x);
return (
n.cross(x).normalize(),
n.length() > 0
? (h.makeRotationAxis(n, S), V.applyMatrix4(h))
: z < 0 && (h.makeRotationZ(Math.PI), V.applyMatrix4(h)),
null != c &&
(n
.copy(r)
.addScaledVector(x, f / 2)
.sub(c),
h.makeTranslation(n.x, n.y, n.z),
V.applyMatrix4(h)),
V.array
);
}
equals(t) {
return (
this.base.equals(t.base) &&
this.axis.equals(t.axis) &&
this.height === t.height &&
this.radius0 === t.radius0 &&
this.radius1 === t.radius1
);
}
}
(e.ConeFrustum = u),
(e.Ray.prototype.intersectsConeFrustum = (function() {
const t = new i(),
e = new i(),
s = new i();
return function(i, a) {
null == a && (a = e);
const o = i.radius1 - i.radius0,
n = 1 + Math.pow(o / i.height, 2),
r = (i.radius0 * o) / i.height;
t.subVectors(this.origin, i.base);
const h = t.dot(i.axis),
c = t.dot(t),
u = this.direction.dot(i.axis),
d = this.direction.dot(t),
l = this.direction.dot(this.direction),
p = i.radius0 * i.radius0 + 2 * r * h + n * h * h - c,
x = r * u + n * h * u - d,
g = n * u * u - l;
if (0 !== g) {
const o = x * x - g * p;
if (o < 0) return null;
if (0 !== o) {
let n = 0;
const r = Math.sqrt(o),
h = (-x - r) / g;
s.copy(t), s.addScaledVector(this.direction, h);
let c = i.axis.dot(s);
h >= 0 && c >= 0 && c <= i.height && (e.addVectors(i.base, s), n++);
const u = (-x + r) / g;
return (
s.copy(t),
s.addScaledVector(this.direction, u),
(c = i.axis.dot(s)),
u >= 0 &&
(0 === n || h > u) &&
c >= 0 &&
c <= i.height &&
(e.addVectors(i.base, s), n++),
n && a.copy(e),
n ? e : null
);
}
{
const o = -x / g;
s.copy(t), s.addScaledVector(this.direction, o);
const n = i.axis.dot(s);
if (o >= 0 && n >= 0 && n <= i.height)
return e.addVectors(i.base, s), a.copy(e), e;
}
} else if (0 !== x) {
const o = (-2 * p) / x;
s.copy(t), s.addScaledVector(this.direction, o);
const n = i.axis.dot(s);
if (o >= 0 && n >= 0 && n <= i.height)
return e.addVectors(i.base, s), a.copy(e), a;
}
return null;
};
})()),
(t.ConeFrustum = u),
Object.defineProperty(t, "__esModule", {value: !0});
});
