!(function(t, s) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = s(require("three-full")))
: "function" == typeof define && define.amd
? define(["three-full"], s)
: (t.THREEConeFrustum = s(t.THREE));
})(this, function(t) {
"use strict";
const s = (t = t && t.hasOwnProperty("default") ? t.default : t).Box3,
i = t.Vector3,
e = t.Matrix4,
a = t.BoxBufferGeometry,
o = new i(),
r = new e(),
n = new a(2, 2, 2).toNonIndexed().attributes.position;
class h {
constructor(t, s, e, a, o) {
(this.base = t || new i()),
(this.axis = s || new i(0, 1, 0)),
this.axis.normalize(),
(this.height = e || 1),
(this.radius0 = a || 0),
(this.radius1 = o || 0);
}
static fromCapsule(t, s, e, a) {
const o = new i().subVectors(e, t);
if (0 === o.length()) throw "Capsule height must not be zero";
const r = (a - s) / o.length(),
n = o.length() + r * (s - a),
d = new i().copy(t).addScaledVector(o.normalize(), -r * s),
c = Math.cos(Math.asin(r));
return new h(d, o, n, s * c, a * c);
}
orthogonalProject(t, s) {
const i = o;
i.subVectors(t, this.base);
const e = i.lengthSq(),
a = i.dot(this.axis),
r = e - a * a,
n =
a - ((r > 0 ? Math.sqrt(r) : 0) * (this.radius0 - this.radius1)) / this.height;
s
.copy(this.axis)
.multiplyScalar(n)
.add(this.base);
}
copy(t) {
(this.base = t.base.clone()),
(this.axis = t.axis.clone()),
(this.height = t.height),
(this.radius0 = t.radius0),
(this.radius1 = t.radius1);
}
clone() {
return new h().copy(this);
}
empty() {
return 0 === this.height || (0 === this.radius0 && 0 === this.radius1);
}
getBoundingBox(t) {
const e = this.base.clone(),
a = new i();
a.set(
Math.sqrt(1 * this.axis.x * this.axis.x),
Math.sqrt(1 * this.axis.y * this.axis.y),
Math.sqrt(1 * this.axis.z * this.axis.z)
),
a.multiplyScalar(this.radius0);
const o = new s(new i().subVectors(e, a), new i().addVectors(e, a));
a.divideScalar(this.radius0),
a.multiplyScalar(this.radius1),
e.addScaledVector(this.axis, this.height);
const r = new s(new i().subVectors(e, a), new i().addVectors(e, a));
return o.union(r), null != t && t.copy(o), o;
}
computeOptimisedBoundingCube(t) {
const s = n.clone(),
i = Math.max(this.radius0, this.radius1);
r.makeScale(i, this.height / 2, i), r.applyToBufferAttribute(s), o.set(0, 1, 0);
const e = o.angleTo(this.axis);
return (
o.cross(this.axis).normalize(),
o.length() > 0 && (r.makeRotationAxis(o, e), r.applyToBufferAttribute(s)),
o
.copy(this.base)
.addScaledVector(this.axis, this.height / 2)
.sub(t),
r.makeTranslation(o.x, o.y, o.z),
r.applyToBufferAttribute(s),
s.array
);
}
equals(t) {
return (
this.base.equals(t.base) &&
this.axis.equals(t.axis) &&
this.height === t.height &&
this.radius0 === t.radius0 &&
this.radius1 === t.radius1
);
}
}
(t.ConeFrustum = h),
(t.Ray.prototype.intersectsConeFrustum = (function() {
const t = new i(),
s = new i(),
e = new i();
return function(i, a) {
null == a && (a = s);
const o = i.radius1 - i.radius0,
r = 1 + Math.pow(o / i.height, 2),
n = (i.radius0 * o) / i.height;
t.subVectors(this.origin, i.base);
const h = t.dot(i.axis),
d = t.dot(t),
c = this.direction.dot(i.axis),
u = this.direction.dot(t),
l = this.direction.dot(this.direction),
p = i.radius0 * i.radius0 + 2 * n * h + r * h * h - d,
x = n * c + r * h * c - u,
f = r * c * c - l;
if (0 !== f) {
const o = x * x - f * p;
if (o < 0) return null;
if (0 !== o) {
let r = 0;
const n = Math.sqrt(o),
h = (-x - n) / f;
e.copy(t), e.addScaledVector(this.direction, h);
let d = i.axis.dot(e);
h >= 0 && d >= 0 && d <= i.height && (s.addVectors(i.base, e), r++);
const c = (-x + n) / f;
return (
e.copy(t),
e.addScaledVector(this.direction, c),
(d = i.axis.dot(e)),
c >= 0 &&
(0 === r || h > c) &&
d >= 0 &&
d <= i.height &&
(s.addVectors(i.base, e), r++),
r && a.copy(s),
r ? s : null
);
}
{
const o = -x / f;
e.copy(t), e.addScaledVector(this.direction, o);
const r = i.axis.dot(e);
if (o >= 0 && r >= 0 && r <= i.height)
return s.addVectors(i.base, e), a.copy(s), s;
}
} else if (0 !== x) {
const o = (-2 * p) / x;
e.copy(t), e.addScaledVector(this.direction, o);
const r = i.axis.dot(e);
if (o >= 0 && r >= 0 && r <= i.height)
return s.addVectors(i.base, e), a.copy(s), a;
}
return null;
};
})());
return {};
});
