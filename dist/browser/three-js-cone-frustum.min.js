!(function(t, e) {
"object" == typeof exports && "undefined" != typeof module
? e(exports, require("three-full"))
: "function" == typeof define && define.amd
? define(["exports", "three-full"], e)
: e((t.THREEConeFrustum = {}), t.THREE);
})(this, function(t, e) {
"use strict";
class i {
constructor(t, i, s, r, o) {
(this.base = t || new e.Vector3()),
(this.axis = i || new e.Vector3(0, 1, 0)),
this.axis.normalize(),
(this.height = s || 1),
(this.radius0 = r || 0),
(this.radius1 = o || 0);
}
static fromCapsule(t, s, r, o) {
let a = new e.Vector3();
return a.subVectors(r, t), new i(t, a.clone().normalize(), a.length(), s, o);
}
copy(t) {
(this.base = t.base.clone()),
(this.axis = t.axis.clone()),
(this.height = t.height),
(this.radius0 = t.radius0),
(this.radius1 = t.radius1);
}
clone() {
return new i().copy(this);
}
empty() {
return 0 === this.height || (0 === this.radius0 && 0 === this.radius1);
}
getBoundingBox(t) {
let i = this.base.clone(),
s = new e.Vector3();
s.set(
Math.sqrt(1 * this.axis.x * this.axis.x),
Math.sqrt(1 * this.axis.y * this.axis.y),
Math.sqrt(1 * this.axis.z * this.axis.z)
),
s.multiplyScalar(this.radius0);
let r = new e.Box3(
new e.Vector3().subVectors(i, s),
new e.Vector3().addVectors(i, s)
);
s.divideScalar(this.radius0),
s.multiplyScalar(this.radius1),
i.addScaledVector(this.axis, this.height);
let o = new e.Box3(
new e.Vector3().subVectors(i, s),
new e.Vector3().addVectors(i, s)
);
return r.union(o), null != t && t.copy(r), r;
}
equals(t) {
return (
this.base.equals(t.base) &&
this.axis.equals(t.axis) &&
this.height === t.height &&
this.radius0 === t.radius0 &&
this.radius1 === t.radius1
);
}
}
const s = require("three-full");
(s.ConeFrustum = i),
(s.Ray.prototype.intersectsConeFrustum = (function() {
let t = new e.Vector3(),
i = new e.Vector3(),
s = new e.Vector3();
return function(e, r) {
null == r && (r = i);
let o = e.radius1 - e.radius0,
a = 1 + Math.pow(o / e.height, 2),
h = (e.radius0 * o) / e.height;
t.subVectors(this.origin, e.base);
let d = t.dot(e.axis),
n = t.dot(t),
u = this.direction.dot(e.axis),
c = this.direction.dot(t),
l = this.direction.dot(this.direction),
x = e.radius0 * e.radius0 + 2 * h * d + a * d * d - n,
V = h * u + a * d * u - c,
p = a * u * u - l;
if (0 !== p) {
let o = V * V - p * x;
if (o < 0) return null;
if (0 !== o) {
let a = 0,
h = Math.sqrt(o),
d = (-V - h) / p;
s.copy(t), s.addScaledVector(this.direction, d);
let n = e.axis.dot(s);
d >= 0 && n >= 0 && n <= e.height && (i.addVectors(e.base, s), a++);
let u = (-V + h) / p;
return (
s.copy(t),
s.addScaledVector(this.direction, u),
(n = e.axis.dot(s)),
u >= 0 &&
(0 === a || d > u) &&
n >= 0 &&
n <= e.height &&
(i.addVectors(e.base, s), a++),
a && r.copy(i),
a ? i : null
);
}
{
let o = -V / p;
s.copy(t), s.addScaledVector(this.direction, o);
let a = e.axis.dot(s);
if (o >= 0 && a >= 0 && a <= e.height)
return i.addVectors(e.base, s), r.copy(i), i;
}
} else if (0 !== V) {
let o = (-2 * x) / V;
s.copy(t), s.addScaledVector(this.direction, o);
let a = e.axis.dot(s);
if (o >= 0 && a >= 0 && a <= e.height)
return i.addVectors(e.base, s), r.copy(i), r;
}
return null;
};
})()),
(t.ConeFrustum = i),
Object.defineProperty(t, "__esModule", {value: !0});
});
