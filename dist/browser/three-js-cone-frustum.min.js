!(function(t, e) {
"object" == typeof exports && "undefined" != typeof module
? e(exports, require("@dualbox/three"))
: "function" == typeof define && define.amd
? define(["exports", "@dualbox/three"], e)
: e((t.THREEConeFrustum = {}), t.THREE);
})(this, function(t, e) {
"use strict";
var s = "default" in e ? e.default : e;
s.Ray.prototype.intersectsConeFrustum = (function() {
const t = new s.Vector3(),
e = new s.Vector3(),
i = new s.Vector3();
return function(s, o) {
null == o && (o = e);
const a = s.radius1 - s.radius0,
r = 1 + Math.pow(a / s.height, 2),
n = (s.radius0 * a) / s.height;
t.subVectors(this.origin, s.base);
const c = t.dot(s.axis),
h = t.dot(t),
d = this.direction.dot(s.axis),
u = this.direction.dot(t),
l = this.direction.dot(this.direction),
p = s.radius0 * s.radius0 + 2 * n * c + r * c * c - h,
x = n * d + r * c * d - u,
g = r * d * d - l;
if (0 !== g) {
const a = x * x - g * p;
if (a < 0) return null;
if (0 !== a) {
let r = 0;
const n = Math.sqrt(a),
c = (-x - n) / g;
i.copy(t), i.addScaledVector(this.direction, c);
let h = s.axis.dot(i);
c >= 0 && h >= 0 && h <= s.height && (e.addVectors(s.base, i), r++);
const d = (-x + n) / g;
return (
i.copy(t),
i.addScaledVector(this.direction, d),
(h = s.axis.dot(i)),
d >= 0 &&
(0 === r || c > d) &&
h >= 0 &&
h <= s.height &&
(e.addVectors(s.base, i), r++),
r && o.copy(e),
r ? e : null
);
}
{
const a = -x / g;
i.copy(t), i.addScaledVector(this.direction, a);
const r = s.axis.dot(i);
if (a >= 0 && r >= 0 && r <= s.height)
return e.addVectors(s.base, i), o.copy(e), e;
}
} else if (0 !== x) {
const a = (-2 * p) / x;
i.copy(t), i.addScaledVector(this.direction, a);
const r = s.axis.dot(i);
if (a >= 0 && r >= 0 && r <= s.height)
return e.addVectors(s.base, i), o.copy(e), o;
}
return null;
};
})();
const i = new e.Vector3(),
o = (new e.Vector3(), new e.Vector3()),
a = (new e.Vector3(), new e.Matrix4()),
r = new e.BoxBufferGeometry(2, 2, 2).toNonIndexed().attributes.position;
class n {
constructor(t, s, i, o, a) {
(this.base = t || new e.Vector3()),
(this.axis = s || new e.Vector3(0, 1, 0)),
this.axis.normalize(),
(this.height = i || 1),
(this.radius0 = o || 0),
(this.radius1 = a || 0);
}
static fromCapsule(t, s, i, o) {
if (s > o) return this.fromCapsule(i, o, t, s);
const a = new e.Vector3().subVectors(i, t);
if (0 === a.length()) throw "Capsule height must not be zero";
const r = (o - s) / a.length(),
c = a.length() + r * (s - o),
h = new e.Vector3().copy(t).addScaledVector(a.normalize(), -r * s),
d = Math.cos(Math.asin(r));
return new n(h, a, c, s * d, o * d);
}
orthogonalProject(t, e) {
const s = i;
s.subVectors(t, this.base);
const o = s.lengthSq(),
a = s.dot(this.axis),
r = o - a * a,
n =
a - ((r > 0 ? Math.sqrt(r) : 0) * (this.radius0 - this.radius1)) / this.height;
e
.copy(this.axis)
.multiplyScalar(n)
.add(this.base);
}
copy(t) {
(this.base = t.base.clone()),
(this.axis = t.axis.clone()),
(this.height = t.height),
(this.radius0 = t.radius0),
(this.radius1 = t.radius1);
}
clone() {
return new n().copy(this);
}
empty() {
return 0 === this.height || (0 === this.radius0 && 0 === this.radius1);
}
getBoundingBox(t) {
const s = this.base.clone(),
i = new e.Vector3();
i.set(
Math.sqrt(1 - this.axis.x * this.axis.x),
Math.sqrt(1 - this.axis.y * this.axis.y),
Math.sqrt(1 - this.axis.z * this.axis.z)
),
i.multiplyScalar(this.radius0);
const o = new e.Box3(
new e.Vector3().subVectors(s, i),
new e.Vector3().addVectors(s, i)
);
i.divideScalar(this.radius0),
i.multiplyScalar(this.radius1),
s.addScaledVector(this.axis, this.height);
const a = new e.Box3(
new e.Vector3().subVectors(s, i),
new e.Vector3().addVectors(s, i)
);
return o.union(a), null != t && t.copy(o), o;
}
computeOptimisedBoundingCube(t) {
const e = r.clone(),
s = Math.max(this.radius0, this.radius1);
a.makeScale(s, this.height / 2, s), e.applyMatrix4(a), i.set(0, 1, 0);
const o = i.angleTo(this.axis);
return (
i.cross(this.axis).normalize(),
i.length() > 0 && (a.makeRotationAxis(i, o), e.applyMatrix4(a)),
i
.copy(this.base)
.addScaledVector(this.axis, this.height / 2)
.sub(t),
a.makeTranslation(i.x, i.y, i.z),
e.applyMatrix4(a),
e.array
);
}
static computeOptimisedDownscalingBoundingCube(t, s, r, n, c, h) {
if (s > n)
return this.computeOptimisedDownscalingBoundingCube(r, n, t, s, c, h);
const d = new Float32Array([
-1,
-1,
-1,
1,
-1,
-1,
-1,
-1,
1,
1,
-1,
1,
-1,
1,
-1,
1,
1,
-1,
-1,
1,
1,
1,
1,
1,
-1,
1,
-1,
1,
1,
-1,
-1,
1,
1,
1,
1,
1
]),
u = [
0,
1,
3,
0,
3,
2,
6,
4,
0,
6,
0,
2,
7,
6,
2,
7,
2,
3,
5,
7,
3,
5,
3,
1,
4,
5,
1,
4,
1,
0,
10,
8,
4,
10,
4,
6,
11,
10,
6,
11,
6,
7,
9,
11,
7,
9,
7,
5,
8,
9,
5,
8,
5,
4,
9,
8,
10,
9,
10,
11
],
l = function() {
const t = new Float32Array(3 * u.length);
for (let e = 0; e < u.length; e++) {
const s = 3 * u[e];
(t[3 * e] = d[s]), (t[3 * e + 1] = d[s + 1]), (t[3 * e + 2] = d[s + 2]);
}
return t;
},
p = new e.Vector3().subVectors(r, t);
if (0 === p.length()) throw "Capsule height must not be zero";
const x = (n - s) / p.length();
if (Math.abs(x) >= (1 / h) * 0.9999) {
p.addVectors(t, r).multiplyScalar(0.5);
for (let t = 0; t < d.length; t += 3)
(d[t] = p.x), (d[t + 1] = p.y), (d[t + 2] = p.z);
return l();
}
if (Math.abs(x) > 1)
return this.computeOptimisedDownscalingBoundingCube(t, h * s, r, h * n, c, 1);
const g = Math.cos(Math.asin(x)),
y = p.length() + x * (s - h * h * n),
f = p.length() + x * (s - n);
o.copy(t).addScaledVector(p.normalize(), -x * s);
const V = n * g;
let m = V > 0 ? (s * g) / V : 1;
for (let t = 0; t < 12; t += 3) (d[t] *= m), (d[t + 2] *= m);
m = (Math.cos(Math.asin(h * x)) * n * h) / V;
for (let t = 24; t < 36; t += 3) (d[t] *= m), (d[t + 2] *= m);
const b = (2 * f) / y - 1;
for (let t = 12; t < 24; t += 3) d[t + 1] = b;
const w = new e.BufferAttribute(l(), 3);
a.makeScale(V, y / 2, V), w.applyMatrix4(a), i.set(0, 1, 0);
const M = i.angleTo(p),
S = i.dot(p);
return (
i.cross(p).normalize(),
i.length() > 0
? (a.makeRotationAxis(i, M), w.applyMatrix4(a))
: S < 0 && (a.makeRotationZ(Math.PI), w.applyMatrix4(a)),
null != c &&
(i
.copy(o)
.addScaledVector(p, y / 2)
.sub(c),
a.makeTranslation(i.x, i.y, i.z),
w.applyMatrix4(a)),
w.array
);
}
equals(t) {
return (
this.base.equals(t.base) &&
this.axis.equals(t.axis) &&
this.height === t.height &&
this.radius0 === t.radius0 &&
this.radius1 === t.radius1
);
}
}
(s.ConeFrustum = n),
(t.ConeFrustum = n),
Object.defineProperty(t, "__esModule", {value: !0});
});
