!(function(t, e) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = e(require("three-full")))
: "function" == typeof define && define.amd
? define(["three-full"], e)
: (t.THREEConeFrustum = e(t.THREE));
})(this, function(t) {
"use strict";
const e = (t = t && t.hasOwnProperty("default") ? t.default : t).Box3,
s = t.Vector3,
i = t.Matrix4,
a = t.BoxBufferGeometry,
o = new s(),
r = (new s(), new s()),
n = (new s(), new i()),
h = new a(2, 2, 2).toNonIndexed().attributes.position;
class c {
constructor(t, e, i, a, o) {
(this.base = t || new s()),
(this.axis = e || new s(0, 1, 0)),
this.axis.normalize(),
(this.height = i || 1),
(this.radius0 = a || 0),
(this.radius1 = o || 0);
}
static fromCapsule(t, e, i, a) {
if (e > a) return this.fromCapsule(i, a, t, e);
const o = new s().subVectors(i, t);
if (0 === o.length()) throw "Capsule height must not be zero";
const r = (a - e) / o.length(),
n = o.length() + r * (e - a),
h = new s().copy(t).addScaledVector(o.normalize(), -r * e),
u = Math.cos(Math.asin(r));
return new c(h, o, n, e * u, a * u);
}
orthogonalProject(t, e) {
const s = o;
s.subVectors(t, this.base);
const i = s.lengthSq(),
a = s.dot(this.axis),
r = i - a * a,
n =
a - ((r > 0 ? Math.sqrt(r) : 0) * (this.radius0 - this.radius1)) / this.height;
e
.copy(this.axis)
.multiplyScalar(n)
.add(this.base);
}
copy(t) {
(this.base = t.base.clone()),
(this.axis = t.axis.clone()),
(this.height = t.height),
(this.radius0 = t.radius0),
(this.radius1 = t.radius1);
}
clone() {
return new c().copy(this);
}
empty() {
return 0 === this.height || (0 === this.radius0 && 0 === this.radius1);
}
getBoundingBox(t) {
const i = this.base.clone(),
a = new s();
a.set(
Math.sqrt(1 - this.axis.x * this.axis.x),
Math.sqrt(1 - this.axis.y * this.axis.y),
Math.sqrt(1 - this.axis.z * this.axis.z)
),
a.multiplyScalar(this.radius0);
const o = new e(new s().subVectors(i, a), new s().addVectors(i, a));
a.divideScalar(this.radius0),
a.multiplyScalar(this.radius1),
i.addScaledVector(this.axis, this.height);
const r = new e(new s().subVectors(i, a), new s().addVectors(i, a));
return o.union(r), null != t && t.copy(o), o;
}
computeOptimisedBoundingCube(t) {
const e = h.clone(),
s = Math.max(this.radius0, this.radius1);
n.makeScale(s, this.height / 2, s), n.applyToBufferAttribute(e), o.set(0, 1, 0);
const i = o.angleTo(this.axis);
return (
o.cross(this.axis).normalize(),
o.length() > 0 && (n.makeRotationAxis(o, i), n.applyToBufferAttribute(e)),
o
.copy(this.base)
.addScaledVector(this.axis, this.height / 2)
.sub(t),
n.makeTranslation(o.x, o.y, o.z),
n.applyToBufferAttribute(e),
e.array
);
}
static computeOptimisedDownscalingBoundingCube(t, e, i, a, c, u) {
if (e > a)
return this.computeOptimisedDownscalingBoundingCube(i, a, t, e, c, u);
const d = new s().subVectors(i, t);
if (0 === d.length()) throw "Capsule height must not be zero";
const l = h.clone(),
p = (a - e) / d.length();
if (Math.abs(p) > 1) {
d.addVectors(t, i).multiplyScalar(0.5);
for (let t = 0; t < l.array.length; t += 3)
(l.array[t] = d.x), (l.array[t + 1] = d.y), (l.array[t + 2] = d.z);
return l.array;
}
const f = Math.cos(Math.asin(p)),
y = d.length() + p * (e - u * u * a),
g = d.length() + p * (e - a);
r.copy(t).addScaledVector(d.normalize(), -p * e);
const x = y / g,
b = a * f,
m = b > 0 ? (e * f) / (b * x) : 1,
w = l.array;
for (let t = 0; t < w.length; t += 3)
w[t + 1] < 0 && ((w[t] *= m), (w[t + 2] *= m));
n.makeScale(b * x, y / 2, b * x), n.applyToBufferAttribute(l), o.set(0, 1, 0);
const V = o.angleTo(d),
S = o.dot(d);
return (
o.cross(d).normalize(),
o.length() > 0
? (n.makeRotationAxis(o, V), n.applyToBufferAttribute(l))
: S < 0 && (n.makeRotationZ(Math.PI), n.applyToBufferAttribute(l)),
null != c &&
(o
.copy(r)
.addScaledVector(d, y / 2)
.sub(c),
n.makeTranslation(o.x, o.y, o.z),
n.applyToBufferAttribute(l)),
l.array
);
}
equals(t) {
return (
this.base.equals(t.base) &&
this.axis.equals(t.axis) &&
this.height === t.height &&
this.radius0 === t.radius0 &&
this.radius1 === t.radius1
);
}
}
(t.ConeFrustum = c),
(t.Ray.prototype.intersectsConeFrustum = (function() {
const t = new s(),
e = new s(),
i = new s();
return function(s, a) {
null == a && (a = e);
const o = s.radius1 - s.radius0,
r = 1 + Math.pow(o / s.height, 2),
n = (s.radius0 * o) / s.height;
t.subVectors(this.origin, s.base);
const h = t.dot(s.axis),
c = t.dot(t),
u = this.direction.dot(s.axis),
d = this.direction.dot(t),
l = this.direction.dot(this.direction),
p = s.radius0 * s.radius0 + 2 * n * h + r * h * h - c,
f = n * u + r * h * u - d,
y = r * u * u - l;
if (0 !== y) {
const o = f * f - y * p;
if (o < 0) return null;
if (0 !== o) {
let r = 0;
const n = Math.sqrt(o),
h = (-f - n) / y;
i.copy(t), i.addScaledVector(this.direction, h);
let c = s.axis.dot(i);
h >= 0 && c >= 0 && c <= s.height && (e.addVectors(s.base, i), r++);
const u = (-f + n) / y;
return (
i.copy(t),
i.addScaledVector(this.direction, u),
(c = s.axis.dot(i)),
u >= 0 &&
(0 === r || h > u) &&
c >= 0 &&
c <= s.height &&
(e.addVectors(s.base, i), r++),
r && a.copy(e),
r ? e : null
);
}
{
const o = -f / y;
i.copy(t), i.addScaledVector(this.direction, o);
const r = s.axis.dot(i);
if (o >= 0 && r >= 0 && r <= s.height)
return e.addVectors(s.base, i), a.copy(e), e;
}
} else if (0 !== f) {
const o = (-2 * p) / f;
i.copy(t), i.addScaledVector(this.direction, o);
const r = s.axis.dot(i);
if (o >= 0 && r >= 0 && r <= s.height)
return e.addVectors(s.base, i), a.copy(e), a;
}
return null;
};
})());
return {};
});
