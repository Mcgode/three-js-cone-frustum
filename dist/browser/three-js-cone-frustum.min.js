!(function(t, e) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = e(require("three-full")))
: "function" == typeof define && define.amd
? define(["three-full"], e)
: (t.THREEConeFrustum = e(t.THREE));
})(this, function(t) {
"use strict";
const e = (t = t && t.hasOwnProperty("default") ? t.default : t).Box3,
i = t.Vector3;
class s {
constructor(t, e, s, r, a) {
(this.base = t || new i()),
(this.axis = e || new i(0, 1, 0)),
this.axis.normalize(),
(this.height = s || 1),
(this.radius0 = r || 0),
(this.radius1 = a || 0);
}
static fromCapsule(t, e, r, a) {
let o = new i();
return o.subVectors(r, t), new s(t, o.clone().normalize(), o.length(), e, a);
}
copy(t) {
(this.base = t.base.clone()),
(this.axis = t.axis.clone()),
(this.height = t.height),
(this.radius0 = t.radius0),
(this.radius1 = t.radius1);
}
clone() {
return new s().copy(this);
}
empty() {
return 0 === this.height || (0 === this.radius0 && 0 === this.radius1);
}
getBoundingBox(t) {
let s = this.base.clone(),
r = new i();
r.set(
Math.sqrt(1 * this.axis.x * this.axis.x),
Math.sqrt(1 * this.axis.y * this.axis.y),
Math.sqrt(1 * this.axis.z * this.axis.z)
),
r.multiplyScalar(this.radius0);
let a = new e(new i().subVectors(s, r), new i().addVectors(s, r));
r.divideScalar(this.radius0),
r.multiplyScalar(this.radius1),
s.addScaledVector(this.axis, this.height);
let o = new e(new i().subVectors(s, r), new i().addVectors(s, r));
return a.union(o), null != t && t.copy(a), a;
}
equals(t) {
return (
this.base.equals(t.base) &&
this.axis.equals(t.axis) &&
this.height === t.height &&
this.radius0 === t.radius0 &&
this.radius1 === t.radius1
);
}
}
(t.ConeFrustum = s),
(t.Ray.prototype.intersectsConeFrustum = (function() {
let t = new i(),
e = new i(),
s = new i();
return function(i, r) {
null == r && (r = e);
let a = i.radius1 - i.radius0,
o = 1 + Math.pow(a / i.height, 2),
d = (i.radius0 * a) / i.height;
t.subVectors(this.origin, i.base);
let h = t.dot(i.axis),
n = t.dot(t),
u = this.direction.dot(i.axis),
c = this.direction.dot(t),
l = this.direction.dot(this.direction),
x = i.radius0 * i.radius0 + 2 * d * h + o * h * h - n,
f = d * u + o * h * u - c,
p = o * u * u - l;
if (0 !== p) {
let a = f * f - p * x;
if (a < 0) return null;
if (0 !== a) {
let o = 0,
d = Math.sqrt(a),
h = (-f - d) / p;
s.copy(t), s.addScaledVector(this.direction, h);
let n = i.axis.dot(s);
h >= 0 && n >= 0 && n <= i.height && (e.addVectors(i.base, s), o++);
let u = (-f + d) / p;
return (
s.copy(t),
s.addScaledVector(this.direction, u),
(n = i.axis.dot(s)),
u >= 0 &&
(0 === o || h > u) &&
n >= 0 &&
n <= i.height &&
(e.addVectors(i.base, s), o++),
o && r.copy(e),
o ? e : null
);
}
{
let a = -f / p;
s.copy(t), s.addScaledVector(this.direction, a);
let o = i.axis.dot(s);
if (a >= 0 && o >= 0 && o <= i.height)
return e.addVectors(i.base, s), r.copy(e), e;
}
} else if (0 !== f) {
let a = (-2 * x) / f;
s.copy(t), s.addScaledVector(this.direction, a);
let o = i.axis.dot(s);
if (a >= 0 && o >= 0 && o <= i.height)
return e.addVectors(i.base, s), r.copy(e), r;
}
return null;
};
})());
return {};
});
