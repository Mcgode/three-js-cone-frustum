!(function(t, e) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = e(require("three-full")))
: "function" == typeof define && define.amd
? define(["three-full"], e)
: (t.THREEConeFrustum = e(t.THREE));
})(this, function(t) {
"use strict";
const e = (t = t && t.hasOwnProperty("default") ? t.default : t).Box3,
s = t.Vector3,
i = t.Matrix4,
o = t.BoxBufferGeometry,
a = new s(),
n = (new s(), new s()),
r = (new s(), new i()),
h = new o(2, 2, 2).toNonIndexed().attributes.position;
class u {
constructor(t, e, i, o, a) {
(this.base = t || new s()),
(this.axis = e || new s(0, 1, 0)),
this.axis.normalize(),
(this.height = i || 1),
(this.radius0 = o || 0),
(this.radius1 = a || 0);
}
static fromCapsule(t, e, i, o) {
if (e > o) return this.fromCapsule(i, o, t, e);
const a = new s().subVectors(i, t);
if (0 === a.length()) throw "Capsule height must not be zero";
const n = (o - e) / a.length(),
r = a.length() + n * (e - o),
h = new s().copy(t).addScaledVector(a.normalize(), -n * e),
c = Math.cos(Math.asin(n));
return new u(h, a, r, e * c, o * c);
}
orthogonalProject(t, e) {
const s = a;
s.subVectors(t, this.base);
const i = s.lengthSq(),
o = s.dot(this.axis),
n = i - o * o,
r =
o - ((n > 0 ? Math.sqrt(n) : 0) * (this.radius0 - this.radius1)) / this.height;
e
.copy(this.axis)
.multiplyScalar(r)
.add(this.base);
}
copy(t) {
(this.base = t.base.clone()),
(this.axis = t.axis.clone()),
(this.height = t.height),
(this.radius0 = t.radius0),
(this.radius1 = t.radius1);
}
clone() {
return new u().copy(this);
}
empty() {
return 0 === this.height || (0 === this.radius0 && 0 === this.radius1);
}
getBoundingBox(t) {
const i = this.base.clone(),
o = new s();
o.set(
Math.sqrt(1 - this.axis.x * this.axis.x),
Math.sqrt(1 - this.axis.y * this.axis.y),
Math.sqrt(1 - this.axis.z * this.axis.z)
),
o.multiplyScalar(this.radius0);
const a = new e(new s().subVectors(i, o), new s().addVectors(i, o));
o.divideScalar(this.radius0),
o.multiplyScalar(this.radius1),
i.addScaledVector(this.axis, this.height);
const n = new e(new s().subVectors(i, o), new s().addVectors(i, o));
return a.union(n), null != t && t.copy(a), a;
}
computeOptimisedBoundingCube(t) {
const e = h.clone(),
s = Math.max(this.radius0, this.radius1);
r.makeScale(s, this.height / 2, s), r.applyToBufferAttribute(e), a.set(0, 1, 0);
const i = a.angleTo(this.axis);
return (
a.cross(this.axis).normalize(),
a.length() > 0 && (r.makeRotationAxis(a, i), r.applyToBufferAttribute(e)),
a
.copy(this.base)
.addScaledVector(this.axis, this.height / 2)
.sub(t),
r.makeTranslation(a.x, a.y, a.z),
r.applyToBufferAttribute(e),
e.array
);
}
static computeOptimisedDownscalingBoundingCube(e, i, o, h, u, c) {
if (i > h)
return this.computeOptimisedDownscalingBoundingCube(o, h, e, i, u, c);
const d = new Float32Array([
-1,
-1,
-1,
1,
-1,
-1,
-1,
-1,
1,
1,
-1,
1,
-1,
1,
-1,
1,
1,
-1,
-1,
1,
1,
1,
1,
1,
-1,
1,
-1,
1,
1,
-1,
-1,
1,
1,
1,
1,
1
]),
l = [
0,
1,
3,
0,
3,
2,
6,
4,
0,
6,
0,
2,
7,
6,
2,
7,
2,
3,
5,
7,
3,
5,
3,
1,
4,
5,
1,
4,
1,
0,
10,
8,
4,
10,
4,
6,
11,
10,
6,
11,
6,
7,
9,
11,
7,
9,
7,
5,
8,
9,
5,
8,
5,
4,
9,
8,
10,
9,
10,
11
],
p = function() {
const t = new Float32Array(3 * l.length);
for (let e = 0; e < l.length; e++) {
const s = 3 * l[e];
(t[3 * e] = d[s]), (t[3 * e + 1] = d[s + 1]), (t[3 * e + 2] = d[s + 2]);
}
return t;
},
f = new s().subVectors(o, e);
if (0 === f.length()) throw "Capsule height must not be zero";
const g = (h - i) / f.length();
if (Math.abs(g) >= (1 / c) * 0.9999) {
f.addVectors(e, o).multiplyScalar(0.5);
for (let t = 0; t < d.length; t += 3)
(d[t] = f.x), (d[t + 1] = f.y), (d[t + 2] = f.z);
return p();
}
if (Math.abs(g) > 1)
return this.computeOptimisedDownscalingBoundingCube(e, c * i, o, c * h, u, 1);
const y = Math.cos(Math.asin(g)),
b = f.length() + g * (i - c * c * h),
x = f.length() + g * (i - h);
n.copy(e).addScaledVector(f.normalize(), -g * i);
const m = h * y;
let w = m > 0 ? (i * y) / m : 1;
for (let t = 0; t < 12; t += 3) (d[t] *= w), (d[t + 2] *= w);
w = (Math.cos(Math.asin(c * g)) * h * c) / m;
for (let t = 24; t < 36; t += 3) (d[t] *= w), (d[t + 2] *= w);
const V = (2 * x) / b - 1;
for (let t = 12; t < 24; t += 3) d[t + 1] = V;
const B = new t.BufferAttribute(p(), 3);
r.makeScale(m, b / 2, m), r.applyToBufferAttribute(B), a.set(0, 1, 0);
const M = a.angleTo(f),
S = a.dot(f);
return (
a.cross(f).normalize(),
a.length() > 0
? (r.makeRotationAxis(a, M), r.applyToBufferAttribute(B))
: S < 0 && (r.makeRotationZ(Math.PI), r.applyToBufferAttribute(B)),
null != u &&
(a
.copy(n)
.addScaledVector(f, b / 2)
.sub(u),
r.makeTranslation(a.x, a.y, a.z),
r.applyToBufferAttribute(B)),
B.array
);
}
equals(t) {
return (
this.base.equals(t.base) &&
this.axis.equals(t.axis) &&
this.height === t.height &&
this.radius0 === t.radius0 &&
this.radius1 === t.radius1
);
}
}
(t.ConeFrustum = u),
(t.Ray.prototype.intersectsConeFrustum = (function() {
const t = new s(),
e = new s(),
i = new s();
return function(s, o) {
null == o && (o = e);
const a = s.radius1 - s.radius0,
n = 1 + Math.pow(a / s.height, 2),
r = (s.radius0 * a) / s.height;
t.subVectors(this.origin, s.base);
const h = t.dot(s.axis),
u = t.dot(t),
c = this.direction.dot(s.axis),
d = this.direction.dot(t),
l = this.direction.dot(this.direction),
p = s.radius0 * s.radius0 + 2 * r * h + n * h * h - u,
f = r * c + n * h * c - d,
g = n * c * c - l;
if (0 !== g) {
const a = f * f - g * p;
if (a < 0) return null;
if (0 !== a) {
let n = 0;
const r = Math.sqrt(a),
h = (-f - r) / g;
i.copy(t), i.addScaledVector(this.direction, h);
let u = s.axis.dot(i);
h >= 0 && u >= 0 && u <= s.height && (e.addVectors(s.base, i), n++);
const c = (-f + r) / g;
return (
i.copy(t),
i.addScaledVector(this.direction, c),
(u = s.axis.dot(i)),
c >= 0 &&
(0 === n || h > c) &&
u >= 0 &&
u <= s.height &&
(e.addVectors(s.base, i), n++),
n && o.copy(e),
n ? e : null
);
}
{
const a = -f / g;
i.copy(t), i.addScaledVector(this.direction, a);
const n = s.axis.dot(i);
if (a >= 0 && n >= 0 && n <= s.height)
return e.addVectors(s.base, i), o.copy(e), e;
}
} else if (0 !== f) {
const a = (-2 * p) / f;
i.copy(t), i.addScaledVector(this.direction, a);
const n = s.axis.dot(i);
if (a >= 0 && n >= 0 && n <= s.height)
return e.addVectors(s.base, i), o.copy(e), o;
}
return null;
};
})());
return {};
});
